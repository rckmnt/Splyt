<html>
	<head>
		<title> Splyt UI rev </title>
		<style>
			body { margin: 0; background-color: #f0f0f0 }
			canvas { width: 100%; height: 100%; color: #FFF }
		</style>
	</head>
	<body>
		<script src="js/three.min.js"></script>
		<script src="js/OrbitControls.js"></script>
		<script src="js/Detector.js"></script>
	  <script src="js/dat.gui.js"></script>
		<script>

			(function() {
				if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

				var scene, camera, controls, renderer;
				var materials;
				var pi = 3.14159;

				init();
				render();
				animate();

				function init(){

					scene = new THREE.Scene();

					// Camera

					camera = new THREE.PerspectiveCamera( 55, window.innerWidth/window.innerHeight, 0.1, 1000 );
					camera.position.x = 10;
					camera.position.y = 10;
					camera.position.z = 10;

					controls = new THREE.OrbitControls(camera);
					// controls.addEventListener('change', render);

					renderer = new THREE.WebGLRenderer();
					//renderer.setClearColorHex(0xffffff, 1.0);
					renderer.setClearColor(0xffffff, 1);
			    renderer.shadowMapEnabled = true;
					renderer.setSize( window.innerWidth, window.innerHeight );
					document.body.appendChild( renderer.domElement );

					// GUIpanel

		     	var GUIpanel = new function() {
		          this.bHeight = 0.02;
		          this.Ypos = 0.03;
		      }

		      var gui = new dat.GUI();
		      var bHeightController = gui.add(GUIpanel, 'bHeight', 0, 10);
		      var yPosController = gui.add(GUIpanel, 'Ypos', 0, 5);

					bHeightController.onChange(function(value) {
						scene.remove(scene.getObjectByName('splyt'));
						var newMesh = createSplyt('splyt', {
							radius: 0.5,
							baseHeight: value
						});
						scene.add(newMesh);
						render();
					});


		      //AxisHelper

		      var axisHelper = new THREE.AxisHelper( 5 );
					scene.add( axisHelper );

		      // Ground plane

		      var planeGeometry = new THREE.PlaneGeometry(10,10,1,1);
		      var planeMaterial =    new THREE.MeshLambertMaterial({color: 0xffffff, transparent: true, opacity: 0.3, side: THREE.DoubleSide});
		      var plane = new THREE.Mesh(planeGeometry,planeMaterial);
		      plane.receiveShadow  = true;
		      plane.rotation.x=-0.5*Math.PI;
					plane.position.set(0,0,0)
		      scene.add(plane);

					// lights

					light = new THREE.DirectionalLight( 0xffffff );
					light.position.set( 10, 10, 10 );
					scene.add( light );

					light = new THREE.DirectionalLight( 0xffffff );
					light.position.set( -10, -10, -10 );
					scene.add( light );

					light = new THREE.AmbientLight( 0x222222 );
					scene.add( light );

					var splitGeometries = [
						{
							radius: 0.5,
							baseHeight: 5
						}
					];

					splitGeometries.forEach(function(splitGeometry) {
						scene.add(createSplyt('splyt', splitGeometry));
					});

				}

				// Geometry
				function createSplyt(name, geometry) {

					var r = geometry.radius;
					var bHeight = geometry.baseHeight;

					var base = new THREE.CylinderGeometry(r, r, bHeight, 16, 6, false);
					base.translate(0, bHeight/2, 0);

					var rArm = new THREE.CylinderGeometry(r, r, 3, 16, 6, false);
					rArm.translate(0, bHeight, 0);
					rArm.rotateZ(0.25*pi);

					var lArm = new THREE.CylinderGeometry(r, r, 3, 16, 6, false);
					lArm.rotateZ(-0.25*pi);
					lArm.translate(0, bHeight, 0);

					var materials = [
						new THREE.MeshLambertMaterial( { color:  0xFFF9DC, shading: THREE.FlatShading } ),
						new THREE.MeshBasicMaterial( { color: 0x000000, wireframe: true , transparent: true, opacity: 0.1} )
					];

					var smallYGeo = new THREE.Geometry();
					smallYGeo.merge(base, base.matrix);
					smallYGeo.merge(rArm, rArm.matrix);
					smallYGeo.merge(lArm, lArm.matrix);

					var smallYMesh = new THREE.SceneUtils.createMultiMaterialObject(smallYGeo, materials);
					smallYMesh.name = name;
					return smallYMesh;
				};

				function render() {
					renderer.render(scene, camera);
				}

				function animate(){
					requestAnimationFrame( render );
					controls.update();
				}

				function onWindowResize() {
					var windowHalfX = window.innerWidth / 2;
					var windowHalfY = window.innerHeight / 2;

					camera.aspect = window.innerWidth / window.innerHeight;
					camera.updateProjectionMatrix();

					renderer.setSize( window.innerWidth, window.innerHeight );
				}

				render();
			}());
		</script>
	</body>
</html>
